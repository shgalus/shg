/* encoding.cc: character encodings and character sets */

/**
 * \file src/encoding.cc
 * Character encodings and character sets.
 * Created on 7 July 2019.
 */

#include <map>
#include <algorithm>
#include "shg/encoding.h"

#include <iostream>

using std::string, std::u16string, std::u32string;

namespace SHG::Encoding {

Conversion_error::Conversion_error()
     : std::runtime_error("Conversion failed") {}

namespace {

/**
 * Decodes UTF-8 sequence starting from \e it. \returns the first code
 * point found \exception std::invalid_argument if the sequence is
 * incorrect \note On return, the position in \e it is set one
 * character before the beginning of the next sequence. If the
 * exception is thrown, the position in \e it remains undefinite.
 */
char32_t getc(std::string::const_iterator& it,
              std::string::const_iterator end) {
     char32_t u;
     int nbytes;
     unsigned char b = *it;

     if (b < 0x80u) {
          u = b;
          nbytes = 0;
     } else if (b < 0xc0u) {
          goto error;
     } else if (b < 0xe0u) {
          u = b & 0x1fu;
          nbytes = 1;
     } else if (b < 0xf0u) {
          u = b & 0x0fu;
          nbytes = 2;
     } else if (b < 0xf8u) {
          u = b & 0x07u;
          nbytes = 3;
     } else {
          goto error;
     }
     for (int j = 0; j < nbytes; j++)
          if (++it == end || ((b = *it) & 0xc0u) != 0x80u)
               goto error;
          else
               (u <<= 6) += b & 0x3fu;
     // Check for overlong sequence.
     if (u < 0x80u) {
          if (nbytes > 0)
               goto error;
     } else if (u < 0x0800u) {
          if (nbytes > 1)
               goto error;
     } else if (u < 0x10000u) {
          if (nbytes > 2)
               goto error;
     } else if (u > 0x10ffffu) {
          goto error;
     }
     if (is_surrogate(u))
          goto error;
     return u;
error:
     throw Conversion_error();
}

}       // anonymous namespace

std::u32string utf8_to_utf32(const std::string& s) {
     u32string t;
     for (auto it = s.cbegin(); it != s.cend(); ++it)
          t += getc(it, s.cend());
     return t;
}

/**
 * \implementation
 *
 * Code points from 00000000-0000007F (7 bits) are translated as
 * follows:
 * <pre>
 * 0xxxxxxx
 * 0xxxxxxx
 * </pre>
 *
 * Code points from 00000080-000007FF (11 bits) are translated as
 * follows:
 * <pre>
 * 00000yyy xxxxxxxx
 * 110yyyxx 10xxxxxx
 * </pre>
 *
 * Code points from 00000800-0000FFFF (16 bits) are translated as
 * follows:
 * <pre>
 * yyyyyyyy xxxxxxxx
 * 1110yyyy 10yyyyxx 10xxxxxx
 * </pre>
 *
 * Code points from 00010000-001FFFFF (21 bits) are translated as
 * follows:
 * <pre>
 * 000zzzzz yyyyyyyy xxxxxxxx
 * 11110zzz 10zzyyyy 10yyyyxx 10xxxxxx
 * </pre>
 */
std::string utf32_to_utf8(char32_t c) {
     string::size_type nchars;
     unsigned char w[4];

     if (c < 0x80u) {
          w[0] = c;
          nchars = 1;
     } else if (c < 0x0800u) {
          w[0] = 0xc0u + c / 0x40u;
          w[1] = 0x80u + c % 0x40u;
          nchars = 2;
     } else if (c < 0x10000u) {
          if (is_surrogate(c))
               goto error;
          w[0] = 0xe0u + c / 0x1000u;
          c %= 0x1000u;
          w[1] = 0x80u + c / 0x40u;
          w[2] = 0x80u + c % 0x40u;
          nchars = 3;
     } else if (c <= 0x10ffffu) {
          w[0] = 0xf0u + c / 0x40000u;
          c %= 0x40000u;
          w[1] = 0x80u + c / 0x1000u;
          c %= 0x1000u;
          w[2] = 0x80u + c / 0x40u;
          w[3] = 0x80u + c % 0x40u;
          nchars = 4;
     } else {
          goto error;
     }
     return string(reinterpret_cast<char*>(w), nchars);
error:
     throw Conversion_error();
}

std::string utf32_to_utf8(const std::u32string& s) {
     string t;
     for (auto c : s)
          t += utf32_to_utf8(c);
     return t;
}

namespace {

/**
 * Decodes UTF-16 sequence contained in \e s starting from position \e
 * i. \returns the first code point found \exception
 * std::invalid_argument if the sequence is incorrect \note On return,
 * the position in \e i is set one character before the beginning of
 * the next sequence. If the exception is thrown, the position in \e i
 * remains undefinite.
 */
char32_t getc(std::u16string::const_iterator& it,
              std::u16string::const_iterator end) {
     char32_t u;
     char16_t w = *it;

     if (!is_surrogate(w))
          return w;
     if (!is_high_surrogate(w) || ++it == end)
          goto error;
     u = w << 10;
     if (!is_low_surrogate(w = *it))
          goto error;
     return  u + w - 0x35fdc00u;
error:
     throw Conversion_error();
}

}       // anonymous namespace

std::u32string utf16_to_utf32(const std::u16string& s) {
     u32string t;
     for (auto it = s.cbegin(); it != s.cend(); ++it)
          t += getc(it, s.cend());
     return t;
}

/**
 * \implementation
 *
 * Code points from 0000-D7FF and E000-FFFF are translated as one
 * word. Code points from D800-DFFF are UTF-16 surrogates. Code points
 * from 010000-10FFFF are translated as two words as follows:
 * <pre>
 * c -= 0x10000u is a 20-bit number: yyyyyyyyyyxxxxxxxxxx
 * w[0] = 110110yyyyyyyyyy = 0xd800 + yyyyyyyyyy = high surrogate
 * w[1] = 110111xxxxxxxxxx = 0xdc00 + xxxxxxxxxx = low surrogate
 * </pre>
 */
std::u16string utf32_to_utf16(char32_t c) {
     if (c < 0xd800u) {
          return u16string(1, c);
     } else if (c < 0xe000u) {
          // surrogate
     } else if (c < 0x10000u) {
          return u16string(1, c);
     } else if (c < 0x110000u) {
          char16_t w[2];
          c -= 0x10000u;
          w[0] = 0xd800 + c / 0x400u;
          w[1] = 0xdc00 + c % 0x400u;
          return u16string(w, 2);
     }
     throw Conversion_error();
}

std::u16string utf32_to_utf16(const std::u32string& s) {
     u16string t;
     for (auto c : s)
          t += utf32_to_utf16(c);
     return t;
}

namespace {

/**
 * Unicode codes of ISO 8859-2 character set. Characters 0xa0 to 0xff.
 * Source: https://unicode.org/Public/MAPPINGS/ISO8859/8859-2.TXT
 * (June 2019).
 */
constexpr char16_t iso88592[96] = {
     0x00a0, 0x0104, 0x02d8, 0x0141, 0x00a4, 0x013d, 0x015a, 0x00a7,
     0x00a8, 0x0160, 0x015e, 0x0164, 0x0179, 0x00ad, 0x017d, 0x017b,
     0x00b0, 0x0105, 0x02db, 0x0142, 0x00b4, 0x013e, 0x015b, 0x02c7,
     0x00b8, 0x0161, 0x015f, 0x0165, 0x017a, 0x02dd, 0x017e, 0x017c,
     0x0154, 0x00c1, 0x00c2, 0x0102, 0x00c4, 0x0139, 0x0106, 0x00c7,
     0x010c, 0x00c9, 0x0118, 0x00cb, 0x011a, 0x00cd, 0x00ce, 0x010e,
     0x0110, 0x0143, 0x0147, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x00d7,
     0x0158, 0x016e, 0x00da, 0x0170, 0x00dc, 0x00dd, 0x0162, 0x00df,
     0x0155, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x013a, 0x0107, 0x00e7,
     0x010d, 0x00e9, 0x0119, 0x00eb, 0x011b, 0x00ed, 0x00ee, 0x010f,
     0x0111, 0x0144, 0x0148, 0x00f3, 0x00f4, 0x0151, 0x00f6, 0x00f7,
     0x0159, 0x016f, 0x00fa, 0x0171, 0x00fc, 0x00fd, 0x0163, 0x02d9
};

/**
 * ISO 8859-2 equivalents of Unicode code points starting from 0x0080.
 * \sa iso88592
 */
const std::map<char16_t, unsigned char> map_utf32_to_iso88592 {
     {0x0080, 0x80}, {0x0081, 0x81}, {0x0082, 0x82}, {0x0083, 0x83},
     {0x0084, 0x84}, {0x0085, 0x85}, {0x0086, 0x86}, {0x0087, 0x87},
     {0x0088, 0x88}, {0x0089, 0x89}, {0x008a, 0x8a}, {0x008b, 0x8b},
     {0x008c, 0x8c}, {0x008d, 0x8d}, {0x008e, 0x8e}, {0x008f, 0x8f},
     {0x0090, 0x90}, {0x0091, 0x91}, {0x0092, 0x92}, {0x0093, 0x93},
     {0x0094, 0x94}, {0x0095, 0x95}, {0x0096, 0x96}, {0x0097, 0x97},
     {0x0098, 0x98}, {0x0099, 0x99}, {0x009a, 0x9a}, {0x009b, 0x9b},
     {0x009c, 0x9c}, {0x009d, 0x9d}, {0x009e, 0x9e}, {0x009f, 0x9f},
     {0x00a0, 0xa0}, {0x00a4, 0xa4}, {0x00a7, 0xa7}, {0x00a8, 0xa8},
     {0x00ad, 0xad}, {0x00b0, 0xb0}, {0x00b4, 0xb4}, {0x00b8, 0xb8},
     {0x00c1, 0xc1}, {0x00c2, 0xc2}, {0x00c4, 0xc4}, {0x00c7, 0xc7},
     {0x00c9, 0xc9}, {0x00cb, 0xcb}, {0x00cd, 0xcd}, {0x00ce, 0xce},
     {0x00d3, 0xd3}, {0x00d4, 0xd4}, {0x00d6, 0xd6}, {0x00d7, 0xd7},
     {0x00da, 0xda}, {0x00dc, 0xdc}, {0x00dd, 0xdd}, {0x00df, 0xdf},
     {0x00e1, 0xe1}, {0x00e2, 0xe2}, {0x00e4, 0xe4}, {0x00e7, 0xe7},
     {0x00e9, 0xe9}, {0x00eb, 0xeb}, {0x00ed, 0xed}, {0x00ee, 0xee},
     {0x00f3, 0xf3}, {0x00f4, 0xf4}, {0x00f6, 0xf6}, {0x00f7, 0xf7},
     {0x00fa, 0xfa}, {0x00fc, 0xfc}, {0x00fd, 0xfd}, {0x0102, 0xc3},
     {0x0103, 0xe3}, {0x0104, 0xa1}, {0x0105, 0xb1}, {0x0106, 0xc6},
     {0x0107, 0xe6}, {0x010c, 0xc8}, {0x010d, 0xe8}, {0x010e, 0xcf},
     {0x010f, 0xef}, {0x0110, 0xd0}, {0x0111, 0xf0}, {0x0118, 0xca},
     {0x0119, 0xea}, {0x011a, 0xcc}, {0x011b, 0xec}, {0x0139, 0xc5},
     {0x013a, 0xe5}, {0x013d, 0xa5}, {0x013e, 0xb5}, {0x0141, 0xa3},
     {0x0142, 0xb3}, {0x0143, 0xd1}, {0x0144, 0xf1}, {0x0147, 0xd2},
     {0x0148, 0xf2}, {0x0150, 0xd5}, {0x0151, 0xf5}, {0x0154, 0xc0},
     {0x0155, 0xe0}, {0x0158, 0xd8}, {0x0159, 0xf8}, {0x015a, 0xa6},
     {0x015b, 0xb6}, {0x015e, 0xaa}, {0x015f, 0xba}, {0x0160, 0xa9},
     {0x0161, 0xb9}, {0x0162, 0xde}, {0x0163, 0xfe}, {0x0164, 0xab},
     {0x0165, 0xbb}, {0x016e, 0xd9}, {0x016f, 0xf9}, {0x0170, 0xdb},
     {0x0171, 0xfb}, {0x0179, 0xac}, {0x017a, 0xbc}, {0x017b, 0xaf},
     {0x017c, 0xbf}, {0x017d, 0xae}, {0x017e, 0xbe}, {0x02c7, 0xb7},
     {0x02d8, 0xa2}, {0x02d9, 0xff}, {0x02db, 0xb2}, {0x02dd, 0xbd}
};

}       // anonymous namespace

char32_t iso88592_to_utf32(char c) {
     return static_cast<unsigned char>(c) < 0xa0u ?
          static_cast<unsigned char>(c) :
          iso88592[static_cast<unsigned char>(c) - 0xa0u];
}


namespace {

/**
 * Converts string \e s of type \e T1 to string of type \e T2 for
 * strings of characters of constant width. \e f is a function to
 * convert a character.
 */
template <class T1, class T2>
T2 convert(const T1& s,
           typename T2::value_type(*f)(typename T1::value_type)) {
     T2 t(s.size(), typename T2::value_type());
     std::transform(s.cbegin(), s.cend(), t.begin(), f);
     return t;
}

}       // anonymous namespace

std::u32string iso88592_to_utf32(const std::string& s) {
     return convert<string, u32string>(s, iso88592_to_utf32);
}

char utf32_to_iso88592(char32_t c) {
     if (c < 0xa0u)
          return c;
     if (const auto f = map_utf32_to_iso88592.find(c);
         f != map_utf32_to_iso88592.end())
          return f->second;
     throw Conversion_error();
}

std::string utf32_to_iso88592(const std::u32string& s) {
     return convert<u32string, string>(s, utf32_to_iso88592);
}

namespace {

/**
 * Unicode codes of Windows-1250 character set. Characters 0x80 to
 * 0xff. Source:
 * https://unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1250.TXT
 * (July 2019). \note Undefined characters: 0x81, 0x83, 0x88, 0x90,
 * 0x98 have the value 0x0000.
 */
constexpr char16_t windows1250[128] = {
     0x20ac, 0x0000, 0x201a, 0x0000, 0x201e, 0x2026, 0x2020, 0x2021,
     0x0000, 0x2030, 0x0160, 0x2039, 0x015a, 0x0164, 0x017d, 0x0179,
     0x0000, 0x2018, 0x2019, 0x201c, 0x201d, 0x2022, 0x2013, 0x2014,
     0x0000, 0x2122, 0x0161, 0x203a, 0x015b, 0x0165, 0x017e, 0x017a,
     0x00a0, 0x02c7, 0x02d8, 0x0141, 0x00a4, 0x0104, 0x00a6, 0x00a7,
     0x00a8, 0x00a9, 0x015e, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x017b,
     0x00b0, 0x00b1, 0x02db, 0x0142, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
     0x00b8, 0x0105, 0x015f, 0x00bb, 0x013d, 0x02dd, 0x013e, 0x017c,
     0x0154, 0x00c1, 0x00c2, 0x0102, 0x00c4, 0x0139, 0x0106, 0x00c7,
     0x010c, 0x00c9, 0x0118, 0x00cb, 0x011a, 0x00cd, 0x00ce, 0x010e,
     0x0110, 0x0143, 0x0147, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x00d7,
     0x0158, 0x016e, 0x00da, 0x0170, 0x00dc, 0x00dd, 0x0162, 0x00df,
     0x0155, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x013a, 0x0107, 0x00e7,
     0x010d, 0x00e9, 0x0119, 0x00eb, 0x011b, 0x00ed, 0x00ee, 0x010f,
     0x0111, 0x0144, 0x0148, 0x00f3, 0x00f4, 0x0151, 0x00f6, 0x00f7,
     0x0159, 0x016f, 0x00fa, 0x0171, 0x00fc, 0x00fd, 0x0163, 0x02d9
};

/**
 * Windows-1250 equivalents of Unicode code points starting from
 * 0x00a0. \sa windows1250
 */
const std::map<char16_t, unsigned char> map_utf32_to_windows1250 {
     {0x00a0, 0xa0}, {0x00a4, 0xa4}, {0x00a6, 0xa6}, {0x00a7, 0xa7},
     {0x00a8, 0xa8}, {0x00a9, 0xa9}, {0x00ab, 0xab}, {0x00ac, 0xac},
     {0x00ad, 0xad}, {0x00ae, 0xae}, {0x00b0, 0xb0}, {0x00b1, 0xb1},
     {0x00b4, 0xb4}, {0x00b5, 0xb5}, {0x00b6, 0xb6}, {0x00b7, 0xb7},
     {0x00b8, 0xb8}, {0x00bb, 0xbb}, {0x00c1, 0xc1}, {0x00c2, 0xc2},
     {0x00c4, 0xc4}, {0x00c7, 0xc7}, {0x00c9, 0xc9}, {0x00cb, 0xcb},
     {0x00cd, 0xcd}, {0x00ce, 0xce}, {0x00d3, 0xd3}, {0x00d4, 0xd4},
     {0x00d6, 0xd6}, {0x00d7, 0xd7}, {0x00da, 0xda}, {0x00dc, 0xdc},
     {0x00dd, 0xdd}, {0x00df, 0xdf}, {0x00e1, 0xe1}, {0x00e2, 0xe2},
     {0x00e4, 0xe4}, {0x00e7, 0xe7}, {0x00e9, 0xe9}, {0x00eb, 0xeb},
     {0x00ed, 0xed}, {0x00ee, 0xee}, {0x00f3, 0xf3}, {0x00f4, 0xf4},
     {0x00f6, 0xf6}, {0x00f7, 0xf7}, {0x00fa, 0xfa}, {0x00fc, 0xfc},
     {0x00fd, 0xfd}, {0x0102, 0xc3}, {0x0103, 0xe3}, {0x0104, 0xa5},
     {0x0105, 0xb9}, {0x0106, 0xc6}, {0x0107, 0xe6}, {0x010c, 0xc8},
     {0x010d, 0xe8}, {0x010e, 0xcf}, {0x010f, 0xef}, {0x0110, 0xd0},
     {0x0111, 0xf0}, {0x0118, 0xca}, {0x0119, 0xea}, {0x011a, 0xcc},
     {0x011b, 0xec}, {0x0139, 0xc5}, {0x013a, 0xe5}, {0x013d, 0xbc},
     {0x013e, 0xbe}, {0x0141, 0xa3}, {0x0142, 0xb3}, {0x0143, 0xd1},
     {0x0144, 0xf1}, {0x0147, 0xd2}, {0x0148, 0xf2}, {0x0150, 0xd5},
     {0x0151, 0xf5}, {0x0154, 0xc0}, {0x0155, 0xe0}, {0x0158, 0xd8},
     {0x0159, 0xf8}, {0x015a, 0x8c}, {0x015b, 0x9c}, {0x015e, 0xaa},
     {0x015f, 0xba}, {0x0160, 0x8a}, {0x0161, 0x9a}, {0x0162, 0xde},
     {0x0163, 0xfe}, {0x0164, 0x8d}, {0x0165, 0x9d}, {0x016e, 0xd9},
     {0x016f, 0xf9}, {0x0170, 0xdb}, {0x0171, 0xfb}, {0x0179, 0x8f},
     {0x017a, 0x9f}, {0x017b, 0xaf}, {0x017c, 0xbf}, {0x017d, 0x8e},
     {0x017e, 0x9e}, {0x02c7, 0xa1}, {0x02d8, 0xa2}, {0x02d9, 0xff},
     {0x02db, 0xb2}, {0x02dd, 0xbd}, {0x2013, 0x96}, {0x2014, 0x97},
     {0x2018, 0x91}, {0x2019, 0x92}, {0x201a, 0x82}, {0x201c, 0x93},
     {0x201d, 0x94}, {0x201e, 0x84}, {0x2020, 0x86}, {0x2021, 0x87},
     {0x2022, 0x95}, {0x2026, 0x85}, {0x2030, 0x89}, {0x2039, 0x8b},
     {0x203a, 0x9b}, {0x20ac, 0x80}, {0x2122, 0x99}
};

}       // anonymous namespace

char32_t windows1250_to_utf32(char c) {
     const unsigned char uc = c;
     if (uc < 0x80u)
          return uc;
     const char32_t d = windows1250[uc - 0x80u];
     if (d == 0x0000u)
          throw Conversion_error();
     return d;
}

std::u32string windows1250_to_utf32(const std::string& s) {
     return convert<string, u32string>(s, windows1250_to_utf32);
}

char utf32_to_windows1250(char32_t c) {
     if (c < 0xa0u)
          return c;
     if (const auto f = map_utf32_to_windows1250.find(c);
         f != map_utf32_to_windows1250.end())
          return f->second;
     throw Conversion_error();
}

std::string utf32_to_windows1250(const std::u32string& s) {
     return convert<u32string, string>(s, utf32_to_windows1250);
}

std::string::size_type utf8_length(const std::string& s) {
     string::size_type n = 0;
     for (auto it = s.cbegin(); it != s.cend(); ++it, n++)
          getc(it, s.cend());
     return n;
}

std::u16string::size_type utf16_length(const std::u16string& s) {
     u16string::size_type n = 0;
     for (auto it = s.cbegin(); it != s.cend(); ++it, n++)
          getc(it, s.cend());
     return n;
}

}       // namespace SHG::Encoding
